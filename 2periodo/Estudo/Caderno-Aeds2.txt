AEDS 2  

-------------------------------------------------------------------------------------------
Pior caso da Pesquisa Sequencial √© Theta(H) de (n).

Pesquisa bin√°ria alcan√ßa Theta(H) de (lg(n)) compara√ß√µes.

Quick, Heap e Merge Sorts alcan√ßam o Theta(H) de (n x lg(n)) limite inferior de ordena√ß√£o. 

Algoritmos de ordena√ß√£o tais como Bubble, Selection e Insertion fazem Theta(H) de (n¬≤) compara√ß√µes. 

-------------------------------------------------------------------------------------------

===========================================================================================
========================== ALGORITMOS DE ORDENA√á√ÉO ========================================
===========================================================================================

SelectionSort (N√£o Est√°vel)

-> N√£o h√° melhor caso;
-> Melhor uso: quando registros s√£o "grandes", movimenta√ß√µes √© linear;

//===C√ìDIGO===//

for (int i = 0; i < (n - 1); i++) {
    int menor = i;
    for (int j = (i + 1); j < n; j++){
        if (array[menor] > array[j]){
            menor = j;
        }
    }
    swap(menor, i);
}

AN√ÅLISE DE COMPLEXIDADE

movimenta√ß√µes: 3(n-1) =  Œò(n)
compara√ß√µes: Œò(n¬≤)

------------------------------------------------------------------------------------------

InsertionSort (Est√°vel)

->Temos duas sequ√™ncias (a ordenada e a ordenar) e, em cada passo, 
aumentamos a ordenada com um elemento que deve ser inserido em sua posi√ß√£o correta (ordenada);
->Se o elemento a ser ordenado for maior que o √∫ltimo da parte ordenada, ent√£o ele j√° est√° ordenado,
SE N√ÉO, deslocamos os elementos da parte ordenada e inserimos o elemento a ser ordenado na parte correta;

AN√ÅLISE DE COMPLEXIDADE
compara√ß√µes: Melhor: [Œò(n)]  /  Pior: [Œò(n¬≤)]
movimenta√ß√µes:C(n)+1 = Melhor: [Œò(n)]  /  Pior: [Œò(n¬≤)]

Conclus√£o: Melhor caso (mov & comp) = array ordenado
->Pior caso (mov & comp) =array decrescente
->M√©todo a ser utilizado quando o array estiver ‚Äúquase‚Äù ordenado
    *Boa op√ß√£o se desejarmos adicionar alguns itens em um array ordenado
porque seu custo ser√° linear

//===C√ìDIGO===//

for (int i = 1; i < n; i++) {
    int tmp = array[i];
    int j = i - 1;
    while ( (j >= 0) && (array[j] > tmp) ){
        array[j + 1] = array[j];
        j--;
    }
    array[j + 1] = tmp;
}

-------------------------------------------------------------------------------------------

ShellSort (n√£o Est√°vel)

->Faz m√∫ltiplas inser√ß√µes;
->Problema da Inser√ß√£o: menor elemento √† direita, precisa-se fazer n-1 compara√ß√µes e movimenta√ß√µes;
->O m√©todo de Shell contorna esse problema permitindo trocas de registros distantes um do outro;
->h significa quantos grupos ser√£o divididos, exemplo: h=4, h=2, h=1;
->A raz√£o da efici√™ncia do algoritmo ainda n√£o √© conhecida

//===C√ìDIGO===//

void shellsort() {
    int h = 1;
    do { h = (h * 3) + 1; } while (h < n);
    do {
        h /= 3;
        for(int cor = 0; cor < h; cor++){
            insercaoPorCor(cor, h);
        }
    } while (h != 1);
}
void insercaoPorCor(int cor, int h){
    for (int i = (h + cor); i < n; i+=h) {
        int tmp = array[i];
        int j = i - h;
        while ((j >= 0) && (array[j] > tmp)) {
            array[j + h] = array[j];
            j -= h;
        }
        array[j + h] = tmp;
    }
}

-------------------------------------------------------------------------------------------

QuickSort(n√£o Est√°vel)

-> Algoritmo de ordena√ß√£o mais r√°pido para a maioria das situa√ß√µes;
-> Dividir para conquistar;
-> Divide o array em duas partes que ser√£o independentemente ordenadas e a combina√ß√£o de seus resultados produz a solu√ß√£o final
->Particionamento:
    ‚Ä¢Escolha arbitrariamente um piv√¥
    ‚Ä¢Percorra o array a partir da esquerda enquanto array[ i ] < piv√¥
    ‚Ä¢Percorra o array a partir da direita enquanto array[ j ] > piv√¥
    ‚Ä¢Se i ‚â§ j ent√£o troque array[ i ] com array[ j ]
    ‚Ä¢Continue o processo enquanto i ‚â§ j

//===C√ìDIGO===//

void quicksort(int esq, int dir) {
    int i = esq, j = dir, pivo = array[(esq+dir)/2];
    while (i <= j) {
        while (array[i] < pivo)
            i++;
        while (array[j] > pivo)
            j--;
        if (i <= j) {
            swap(i, j);
            i++;
            j--; 
        }
    }
    if (esq < j)
        quicksort(esq, j);
    if (i < dir)
        quicksort(i, dir);
}

AN√ÅLISE DE COMPLEXIDADE

->A an√°lise de complexidade do Quicksort depende de equa√ß√£o de
recorr√™ncia (vista nas disciplinas Teoria dos Grafos e Computabilidade e
Projeto e An√°lise de Algoritmos)

compara√ß√µes: Melhor = Œò[n * lg(n)]  /  Pior = Œò(n¬≤)
movimenta√ß√µes: Melhor = Œò[n * lg(n)]   /  Pior = Œò(n¬≤)

-------------------------------------------------------------------------------------------

HeapSort (N√£o Est√°vel)

->Cont√©m duas etapas, ambas  com custo Œò[n x lg(n)]. A primeira etapa √© a cria√ß√£o do heap, a segunda √© a destrui√ß√£o/ordena√ß√£o do heap.
->O heap √© um TAD que nos fornece ou o menor ou o maior elemnto de um conjunto, com custo Œò (1). O custo de constru√ß√£o √© Œò[n x lg(n)].
Ao remover a cabe√ßa do heap, conseguimos reorganiz√°-lo com custo Œò[lg(n)].
->O heap tradicional armazena o MENOR elemento em sua cabe√ßa. J√° o heap Invertido armazena o MAIOR elemento em sua cabe√ßa e ele √© utilizado no HeapSort


    //=====C√ìDIGO====//

    public void sort() {
      //Alterar o vetor ignorando a posicao zero
      int[] tmp = new int[n+1];
      for(int i = 0; i < n; i++){
         tmp[i+1] = array[i];
      }
      array = tmp;

      //Contrucao do heap
      for(int tamHeap = 2; tamHeap <= n; tamHeap++){
         construir(tamHeap);
      }

      //Ordenacao propriamente dita
      int tamHeap = n;
      while(tamHeap > 1){
         swap(1, tamHeap--);
         reconstruir(tamHeap);
      }

      //Alterar o vetor para voltar a posicao zero
      tmp = array;
      array = new int[n];
      for(int i = 0; i < n; i++){
         array[i] = tmp[i+1];
      }
    }

    public void construir(int tamHeap){
      for(int i = tamHeap; i > 1 && array[i] > array[i/2]; i /= 2){
         swap(i, i/2);
      }
    }
    public void reconstruir(int tamHeap){
      int i = 1;
      while(i <= (tamHeap/2)){
         int filho = getMaiorFilho(i, tamHeap);
         if(array[i] < array[filho]){
            swap(i, filho);
            i = filho;
         }else{
            i = tamHeap;
         }
        }
    }

    public int getMaiorFilho(int i, int tamHeap){
      int filho;
      if (2*i == tamHeap || array[2*i] > array[2*i+1]){
         filho = 2*i;
      } else {
         filho = 2*i + 1;
      }
      return filho;
    }

An√°lise de COMPLEXIDADE
->Depende do tamanho da a≈ïvore (n√∫mero de n√≠veis)

compara√ß√µes: Melhor = Œò[n*lg(n)]
movimenta√ß√µes: Melhor = Œò[n*lg(n)]

OBS.: 1 - O princ√≠pio de inser√ß√£o do heap consiste em inserir uma nova folha no √∫ltimo n√≠vel (o mais a esquerda poss√≠vel). Em seguida, comparamaos a nova folha com o pai.
Se a nova folha for maior que o pai. Invertemos seus valores. Continuaremos "subindo" o novo elemento enquanto ele for maior que o elemento pai; 
2 - Na verdade, o pior caso e o caso m√©dio da primeira etapa do hepsort t√™m custo Œò[n x lg(n)]. A novidade, o melhor caso da primeira etapa do heapsort tem custo Œò[n] e acontece quando
cada elemento inserido no heap for menor ou igual ao seu pai;
3 - O √∫nico momento do heapsort que comparamos elementos irm√£os acontece na remo√ß√£o da cabe√ßa do heap. Nesse caso, comparamos os irm√£os para saber quem ficar√° no lugar do pai.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

BubbleSort (Est√°vel)

-> M√©todo de ordena√ß√£o por sele√ß√£o em que os registros s√£o comparados,
dois a dois e o menor √© movimentado para o in√≠cio do array

/===C√ìDIGO===/

public void sort() {
	for (int i = (n - 1); i > 0; i--) {
		for (int j = 0; j < i; j++) {
			if (array[j] > array[j + 1]) {
               swap(j, j+1);
			}
		}
	}
}

AN√ÅLISE DE COMPLEXIDADE

compara√ß√µes: os tr√™s casos √© Œò(n¬≤)
movimenta√ß√µes: Pior caso (array decrescente)

---------------------------------------------------------------------------------------------------

MergeSort (Est√°vel)

-> Ordena√ß√£o por intercala√ß√£o
-> Algoritmo de ordena√ß√£o do tipo dividir para conquistar
-> Normalmente, implementado de forma recursiva e demandando um
espa√ßo adicional de mem√≥ria (n√£o √© um algoritmo in-place)

*in-place:  Um algoritmo de ordena√ß√£o √© in-place se a mem√≥ria
adicional requerida √© independente do tamanho do array

/===C√ìDIGO===/

void mergesort(int esq, int dir) {
    if (esq < dir){
        int meio = (esq + dir) / 2;
        mergesort(esq, meio);
        mergesort(meio + 1, dir);
        intercalar(esq, meio, dir);
    }
}
void intercalar(int esq, int meio, int dir){
    //Definir tamanho dos dois subarrays
    int nEsq = (meio+1)-esq;
    int nDir = dir - meio;

    int[] arrayEsq = new int[nEsq+1];
    int[] arrayDir = new int[nDir+1];

    //Sentinela no final dos dois arrays
    arrayEsq[nEsq] = arrayDir[nDir] = 0x7FFFFFFF;
    int iEsq, iDir, i;

    //Inicializar primeiro subarray
    for (iEsq = 0; iEsq < nEsq; iEsq++){
        arrayEsq[iEsq] = array[esq+iEsq];
    }

    //Inicializar segundo subarray
    for (iDir = 0; iDir < nDir; iDir++){
        arrayDir[iDir] = array[(meio+1)+iDir];
    }

    //Intercalacao propriamente dita
    for (iEsq = iDir = 0, i = esq; i <= dir; i++){
        array[i] = (arrayEsq[iEsq] <= arrayDir[iDir]) ? arrayEsq[iEsq++] : arrayDir[iDir++];
    }
}

AN√ÅLISE DE COMPLEXIDADE

compara√ß√µes: todos casos: Œò[n*lg(n)]
movimenta√ß√µes: todos casos: Œò[n*lg(n)]

-------------------------------------------------------------------------------------------------------

CountingSort (Est√°vel)

‚Ä¢ Inicializar todas as posi√ß√µes do array de contagem com zero
ùöØ(n)
‚Ä¢ Para cada elemento do array de entrada, increment√°-lo no de contagem
ùöØ(n)
‚Ä¢ Fazer com que o array de contagem seja acumulativo de tal forma que
cada posi√ß√£o i armazene o n√∫mero de elementos menores ou iguais a i
ùöØ(n)
‚Ä¢ Sabendo o n√∫mero de elementos menores ou iguais a i, preencher o array
de sa√≠da
ùöØ(n)

/===COD√çGO===/

void countingsort() {
    //Array para contar o numero de ocorrencias de cada elemento
    int[] count = new int[getMaior() + 1];
    int[] ordenado = new int[n];
    
    //Inicializar cada posicao do array de contagem
    for (int i = 0; i < count.length; count[i] = 0, i++);
    
    //Agora, o count[i] contem o numero de elemento iguais a i
    for (int i = 0; i < n; count[array[i]]++, i++);
    
    //Agora, o count[i] contem o numero de elemento menores ou iguais a i
    for (int i = 1; i < count.length; count[i] += count[i- 1], i++);
    
    //Ordenando
    for (int i = n-1; i >= 0; ordenado[count[array[i]]-1] = array[i], count[array[i]]--, i--);
}

===========================================================================================================

ORDENA√á√ÉO PARCIAL

Em um array de n elementos, achamos os k menores/maiores elementos desse array, sendo k < n;
k << n  => k muito menor que n;
